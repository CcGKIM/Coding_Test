# 🚀 BFS를 활용한 벽 부수고 이동하기 문제 풀이

## 📌 1. 문제 개요

주어진 `N x M` 크기의 맵에서 `(0,0)`에서 출발하여 `(N-1, M-1)`까지 이동하는 **최단 거리**를 구하는 문제이다.  
단, **한 개의 벽을 부술 수 있는 기회가 주어진다**는 점이 특징이다.

---

## 🔎 2. 접근 방식

이 문제는 **BFS(Breadth-First Search)** 를 사용하여 **최단 거리 탐색**을 수행해야 한다.  
여기에 **벽을 한 번만 부술 수 있는 상태(가능/불가능)를 함께 관리**해야 하므로,  
**3차원 `visited` 리스트**를 활용하여 상태를 추적한다.

- `visited[0][x][y]` → 벽을 부수지 않고 방문한 경우
- `visited[1][x][y]` → 벽을 한 번 부순 상태에서 방문한 경우

이렇게 하면 **벽을 부순 후 방문한 상태와 부수지 않은 상태를 구분하여 BFS 탐색을 진행할 수 있다**.

---

## 💻 3. 코드 구현

```python
from collections import deque
import sys

# 입력 받기
N, M = map(int, sys.stdin.readline().split())
matrix = [list(map(int, sys.stdin.readline().strip())) for _ in range(N)]

# 초기값 설정
answer = int(1e9)

# BFS 탐색
def bfs(start_x, start_y):
    global answer

    # 방문 여부 저장 (벽을 부순 경우와 부수지 않은 경우를 구분)
    visited = [[[False] * M for _ in range(N)] for _ in range(2)]

    # 방향 벡터 (상, 하, 좌, 우)
    dx = (-1, 1, 0, 0)
    dy = (0, 0, -1, 1)

    # BFS 시작
    queue = deque()
    queue.append((start_x, start_y, True, 1))  # (x, y, 벽 부수기 가능 여부, 이동 거리)
    visited[0][start_x][start_y] = True  # 벽을 부수지 않은 상태로 (0,0) 방문 처리

    while queue:
        x, y, bomb, dist = queue.popleft()

        # 목적지에 도달하면 최소 거리 갱신
        if x == N - 1 and y == M - 1:
            answer = min(dist, answer)
            continue

        # 네 방향 탐색
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]

            # 벽을 부수고 이동하는 경우
            if bomb and 0 <= nx < N and 0 <= ny < M and not visited[1][nx][ny] and matrix[nx][ny] == 1:
                visited[1][nx][ny] = True
                queue.append((nx, ny, False, dist + 1))

            # 벽이 없는 곳으로 이동하는 경우 (벽 부수기 가능)
            elif bomb and 0 <= nx < N and 0 <= ny < M and not visited[0][nx][ny] and matrix[nx][ny] == 0:
                visited[0][nx][ny] = True
                queue.append((nx, ny, bomb, dist + 1))

            # 벽을 이미 부순 상태에서 이동하는 경우
            elif not bomb and 0 <= nx < N and 0 <= ny < M and not visited[1][nx][ny] and matrix[nx][ny] == 0:
                visited[1][nx][ny] = True
                queue.append((nx, ny, bomb, dist + 1))

# BFS 실행
bfs(0, 0)

# 결과 출력
print(-1 if answer == int(1e9) else answer)
```
