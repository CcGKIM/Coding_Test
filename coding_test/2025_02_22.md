```
import sys

# 입력 받기
N = int(sys.stdin.readline().strip())  # 숫자의 개수 입력
array = list(map(int, sys.stdin.readline().split()))  # 정수 리스트 입력
array.sort()  # 정렬 수행

# 투 포인터 초기화
left = 0
right = N - 1
result = float('inf')  # 절댓값이 가장 작은 값을 찾기 위해 무한대 초기화
answer = [array[left], array[right]]  # 결과 저장 변수

# 투 포인터 알고리즘 실행
while left < right:
    x = array[left] + array[right]

    # 절댓값이 더 작은 경우 정답 갱신
    if result > abs(x):
        result = abs(x)
        answer = [array[left], array[right]]

    # 용액 합이 0보다 크면 right 감소, 작으면 left 증가
    if x > 0:
        right -= 1
    elif x < 0:
        left += 1
    else:
        break  # 정확히 0이면 최적이므로 즉시 종료

# 정답 출력 (오름차순 정렬 후)
answer.sort()
print(answer[0], answer[1])
```

```
import sys

# 입력 받기
N = int(sys.stdin.readline().strip())  # 정수의 개수 입력
array = list(map(int, sys.stdin.readline().split()))  # N개의 정수 입력
array.sort()  # 정렬 수행 (이진 탐색 사용을 위해 필수)

result = float('inf')  # 절댓값이 가장 작은 값 초기화
answer = [0, 0]  # 결과 저장

# 이진 탐색을 이용한 최적의 두 용액 찾기
def two_search(init_idx):
    left = init_idx + 1
    right = len(array) - 1
    best_pair = [array[init_idx], array[left]]

    while left <= right:
        mid = (left + right) // 2
        x = array[init_idx] + array[mid]

        # 현재 선택한 용액 쌍이 기존보다 더 0에 가까운 경우 갱신
        if abs(sum(best_pair)) > abs(x):
            best_pair = [array[init_idx], array[mid]]

        # 용액 합이 0보다 크다면 값을 줄이기 위해 right 이동
        if x > 0:
            right = mid - 1
        # 용액 합이 0보다 작다면 값을 키우기 위해 left 이동
        elif x < 0:
            left = mid + 1
        # 0이면 최적의 값이므로 즉시 종료
        else:
            return best_pair

    return best_pair

# 각 용액을 기준으로 가장 최적의 짝 찾기
for i in range(len(array) - 1):
    x, y = two_search(i)
    if result > abs(x + y):
        result = abs(x + y)
        answer = [x, y]

# 결과 출력 (오름차순 정렬 후)
answer.sort()
print(answer[0], answer[1])
```
